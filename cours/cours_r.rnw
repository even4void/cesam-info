%
% A temptative draft.
%
\documentclass[10pt,a4paper]{report}

\usepackage[hmargin=2cm,vmargin=2.5cm]{geometry}
\usepackage{parskip}
\usepackage{titlesec}
\usepackage[outercaption]{sidecap}
\usepackage{caption}
\usepackage{xcolor}
\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}
\usepackage{mathpazo}
\usepackage{url}
\usepackage{xspace}
\usepackage[french=guillemets*]{csquotes} 

% Custom settings and macros
\MakeOuterQuote{"} 
\definecolor{gray15}{gray}{0.15}
\definecolor{gray35}{gray}{0.35}
\definecolor{gray75}{gray}{0.75}
\newcommand{\hsp}{\hspace{20pt}}
\titleformat{\chapter}[hang]{\LARGE\bfseries}{\thechapter.\hsp}{0pt}{\LARGE\bfseries\textcolor{gray15}}
\titleformat*{\section}{\color{gray35}\bfseries\Large}
\titleformat*{\subsection}{\color{gray35}\bfseries\large}
\captionsetup[figure]{textfont=sf,labelformat=empty,singlelinecheck=on}
\sidecaptionvpos{figure}{c}
\newcommand{\R}{\textsf{R}\xspace}

% Bibliography
\usepackage[style=verbose-trad2,natbib=true,backend=bibtex]{biblatex}
\bibliography{refs}

% Index
\usepackage{multicol}
\usepackage{makeidx}
\addto\captionsfrancais{%
\renewcommand*\indexname{Liste des commandes \R}}
\newcommand{\foo}[1]{\texttt{#1}}
\newcommand{\cmd}[1]{\index{#1@\foo{#1}}}


\begin{document}

<<setup, echo=FALSE, message=FALSE>>=
opts_knit$set(echo=FALSE, message=FALSE, cache=TRUE, size='tiny')
opts_knit$set(aliases=c(h='fig.height', w='fig.width',                cap='fig.cap', scap='fig.scap'))
opts_knit$set(eval.after = c('fig.cap','fig.scap'))
opts_chunk$set(fig.env='SCfigure', fig.width=5, fig.height=5,                out.width='.55\\linewidth', prompt=TRUE, comment=NA, background='#FFFFFF')
library(lattice)
library(latticeExtra)
trellis.par.set(custom.theme.2())
trellis.par.set("strip.background"=list(col="transparent"))
options(width=100, digits=3, scipen=6, show.signif.stars=FALSE)
set.seed(101)
@ 
	

\chapter{Guide de démarrage} % (fold)
\label{cha:guide_de_demarrage}

% chapter guide_de_démarrage (end)	

\chapter{Éléments du langage} % (fold)
\label{cha:elements_du_langage}

<<>>=
data(birthwt, package="MASS")
yesno <- c("No","Yes")
birthwt <- within(birthwt, {
  low <- factor(low, labels=yesno)
  race <- factor(race, labels=c("White","Black","Other"))
  smoke <- factor(smoke, labels=yesno)
  ui <- factor(ui, labels=yesno)
  ht <- factor(ht, labels=yesno)
})
@


% chapter éléments_du_langage (end)

\chapter{Mesures et tests d'association entre deux variables} % (fold)
\label{cha:mesures_et_tests_d_association_entre_deux_variables}

\section{Commandes essentielles} % (fold)
\label{sec:commandes_essentielles}

\begin{description}
	\item[] \verb|tapply(x, g, mean)| \\ Calcule la moyenne des \verb|x| conditionnellement aux niveaux ou modalités du facteur \verb|g| 
	\item[] \verb|t.test(x ~ g, var.equal=TRUE, paired=FALSE)| \\ Réalise un test t de Student pour deux échantillons indépendants en supposant l'homogénéité des variances. Une correction de Satterwaithe (test de Welch) est obtenue avec l'option \verb|var.equal=FALSE|. L'option \verb|paired=TRUE| permet de considérer deux échantillons appariés. 
	\item[] \verb|wilcox.test(x ~ g, paired=FALSE)| \\ Réalise un test de Wilcoxon pour deux échantillons indépendants. L'option \verb|paired=TRUE| permet de considérer deux échantillons appariés.
\end{description}
% section commandes_essentielles (end)

\section{Statistiques descriptives} % (fold)
\label{sec:statistiques_descriptives}

On peut très bien calculer les moyennes de groupe en sélectionnant les
observations appartenant à chacun des groupes, ou niveau du facteur d'étude. Par exemple, dans l'étude sur les poids à la naissance l'âge moyen des mères de bébés nés avec un poids inférieur à 2,5 kg vaut
<<>>=
with(birthwt, mean(age[bwt < 2500]))
@
ou de manière équivalente
<<eval=FALSE>>=
mean(age[low == "Yes"])
@
On procèderait de la même manière pour calculer l'âge moyen des mères ayant eu un enfant dans les normes du point de vue du poids de naissance (\verb|mean(age[low == "No"])|). 

Cependant, il est souvent plus commode de grouper de genre d'opérations (calcul d'une statistique quelconque) à l'aide de la commande \verb|tapply| en indiquant le facteur sur lequel on souhaite opérer. 
<<>>=
with(birthwt, tapply(age, low, mean))
@
Le troisième argument de la commande \verb|tapply| est une commande \R ou n'importe quelle combinaison de commandes. On pourrait très bien définir une "fonction" qui calcule moyenne et écart-type, comme ceci
<<>>=
f <- function(x) c(m=mean(x), s=sd(x))
@
et l'utiliser en lieu et place de la commande \verb|mean| :
<<>>=
with(birthwt, tapply(age, low, f))
@

On peut examiner la distribution des âges selon le status pondéral à l'aide d'un histogramme, en indiquant la variable de stratification (\verb|low|) à l'aide de l'opérateur \verb+|+. L'avantage de cette approche est que \R utilisera le même système d'unités pour l'axe des ordonnées, ce qui facilite souvent la comparaison entre les distributions conditionnelles.  
<<fig=TRUE, cap="Histogramme pour la distribution de l'âge des mères conditionnellement au status pondéral à la naissance.">>=
histogram(~ age | low, data=birthwt, type="count")
@

On pourrait tout aussi bien utiliser des courbes de densité au lieu d'histogrammes. La commande à utiliser est alors \verb|densityplot| et les options restent strictement identiques à celles utilisées avec \verb|histogram|, à l'exception de l'option \verb|type="count"|.
<<fig=TRUE, cap="Courbes de desnité pour la distribution de l'âge des mères conditionnellement au status pondéral à la naissance.">>=
densityplot(~ age | low, data=birthwt, bw=2.5)
@

 
% section statistiques_descriptives (end)

% chapter mesures_et_tests_d_association_entre_deux_variables (end)
\end{document}
